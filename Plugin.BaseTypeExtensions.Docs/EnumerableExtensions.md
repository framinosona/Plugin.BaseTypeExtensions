# ðŸ“‹ EnumerableExtensions

Provides powerful LINQ-style operations and utilities for IEnumerable collections.

## Overview

The `EnumerableExtensions` class offers enhanced collection operations including chunking, batch processing, conditional operations, and advanced LINQ extensions.

## Batch Processing

### Chunking Operations

#### `ChunkBy<T>(IEnumerable<T> source, int size)`\nSplits collection into chunks of specified size.\n\n```csharp\nvar numbers = Enumerable.Range(1, 10);\nvar chunks = numbers.ChunkBy(3);\n// Result: [[1,2,3], [4,5,6], [7,8,9], [10]]\n\nforeach (var chunk in chunks)\n{\n    Console.WriteLine($\"Chunk: [{string.Join(\", \", chunk)}]\");\n}\n```\n\n### Batch Processing\n\n#### `ProcessInBatches<T>(IEnumerable<T> source, int batchSize, Action<IEnumerable<T>> processor)`\nProcesses collection in batches with specified action.\n\n```csharp\nvar largeDataset = GetLargeDataset();\n\n// Process 100 items at a time\nlargeDataset.ProcessInBatches(100, batch => \n{\n    // Process batch efficiently\n    var results = ProcessBatchInDatabase(batch);\n    logger.LogInformation($\"Processed {batch.Count()} items\");\n});\n```\n\n## Conditional Operations\n\n### WhereIf Extension\n\n#### `WhereIf<T>(IEnumerable<T> source, bool condition, Func<T, bool> predicate)`\nApplies filter only if condition is true.\n\n```csharp\nvar users = GetUsers();\nvar includeInactive = GetUserPreference();\n\nvar filteredUsers = users\n    .WhereIf(!includeInactive, u => u.IsActive)\n    .WhereIf(hasAdminRights, u => u.Department == \"IT\");\n```\n\n### SelectIf Extension\n\n#### `SelectIf<T, TResult>(IEnumerable<T> source, bool condition, Func<T, TResult> selector, Func<T, TResult> alternativeSelector)`\nConditional selection with fallback.\n\n```csharp\nvar users = GetUsers();\nvar showFullName = GetDisplayPreference();\n\nvar displayNames = users.SelectIf(\n    showFullName,\n    u => $\"{u.FirstName} {u.LastName}\",\n    u => u.FirstName\n);\n```\n\n## Advanced LINQ Operations\n\n### Distinct Operations\n\n#### `DistinctBy<T, TKey>(IEnumerable<T> source, Func<T, TKey> keySelector)`\nReturns distinct elements by specified key.\n\n```csharp\nvar users = GetUsers();\nvar uniqueByEmail = users.DistinctBy(u => u.Email);\nvar uniqueByDepartment = users.DistinctBy(u => u.Department);\n```\n\n### Safety Extensions\n\n#### `EmptyIfNull<T>(IEnumerable<T>? source)`\nReturns empty collection if source is null.\n\n```csharp\nIEnumerable<string>? potentiallyNull = GetOptionalData();\nvar safeEnumerable = potentiallyNull.EmptyIfNull();\n\n// Safe to enumerate without null checks\nforeach (var item in safeEnumerable)\n{\n    ProcessItem(item);\n}\n```\n\n#### `IsNullOrEmpty<T>(IEnumerable<T>? source)`\nChecks if collection is null or empty.\n\n```csharp\nvar items = GetItems();\nif (items.IsNullOrEmpty())\n{\n    DisplayNoItemsMessage();\n    return;\n}\n\nProcessItems(items);\n```\n\n## Aggregation Operations\n\n### Statistical Functions\n\n#### `MaxBy<T, TComparable>(IEnumerable<T> source, Func<T, TComparable> selector)`\nFinds element with maximum value by selector.\n\n```csharp\nvar employees = GetEmployees();\nvar highestPaid = employees.MaxBy(e => e.Salary);\nvar oldestEmployee = employees.MaxBy(e => e.Age);\n```\n\n#### `MinBy<T, TComparable>(IEnumerable<T> source, Func<T, TComparable> selector)`\nFinds element with minimum value by selector.\n\n```csharp\nvar products = GetProducts();\nvar cheapestProduct = products.MinBy(p => p.Price);\nvar newestProduct = products.MinBy(p => p.CreatedDate);\n```\n\n### Collection Comparison\n\n#### `ExceptBy<T, TKey>(IEnumerable<T> first, IEnumerable<T> second, Func<T, TKey> keySelector)`\nReturns elements from first collection not in second by key.\n\n```csharp\nvar allUsers = GetAllUsers();\nvar activeUsers = GetActiveUsers();\nvar inactiveUsers = allUsers.ExceptBy(activeUsers, u => u.Id);\n```\n\n## Practical Examples\n\n### Data Processing Pipeline\n\n```csharp\npublic async Task<ProcessingResult> ProcessLargeDatasetAsync(\n    IEnumerable<DataRecord> records,\n    ProcessingOptions options)\n{\n    var results = new List<ProcessedRecord>();\n    var errors = new List<ProcessingError>();\n    \n    var validRecords = records\n        .EmptyIfNull()\n        .WhereIf(options.SkipInvalid, r => r.IsValid)\n        .DistinctBy(r => r.Id);\n    \n    await validRecords.ProcessInBatchesAsync(options.BatchSize, async batch =>\n    {\n        try\n        {\n            var processed = await ProcessBatchAsync(batch);\n            results.AddRange(processed);\n        }\n        catch (Exception ex)\n        {\n            errors.Add(new ProcessingError \n            { \n                BatchId = batch.First().Id, \n                Error = ex.Message \n            });\n        }\n    });\n    \n    return new ProcessingResult\n    {\n        Processed = results,\n        Errors = errors,\n        TotalProcessed = results.Count\n    };\n}\n```\n\n### Report Generation\n\n```csharp\npublic class SalesReportGenerator\n{\n    public SalesReport GenerateReport(IEnumerable<Sale> sales, ReportOptions options)\n    {\n        var filteredSales = sales\n            .EmptyIfNull()\n            .WhereIf(options.DateRange.HasValue, s => \n                s.Date >= options.DateRange.Value.Start && \n                s.Date <= options.DateRange.Value.End)\n            .WhereIf(!string.IsNullOrEmpty(options.Region), s => \n                s.Region.Equals(options.Region, StringComparison.OrdinalIgnoreCase));\n        \n        var topPerformers = filteredSales\n            .GroupBy(s => s.SalesPersonId)\n            .Select(g => new \n            {\n                SalesPersonId = g.Key,\n                TotalSales = g.Sum(s => s.Amount),\n                SalesCount = g.Count()\n            })\n            .OrderByDescending(x => x.TotalSales)\n            .Take(options.TopPerformersCount);\n        \n        var regionAnalysis = filteredSales\n            .GroupBy(s => s.Region)\n            .Select(g => new RegionSummary\n            {\n                Region = g.Key,\n                TotalSales = g.Sum(s => s.Amount),\n                AverageSale = g.Average(s => s.Amount),\n                TopProduct = g.MaxBy(s => s.Amount)?.ProductName\n            });\n        \n        return new SalesReport\n        {\n            TotalSales = filteredSales.Sum(s => s.Amount),\n            TopPerformers = topPerformers.ToList(),\n            RegionAnalysis = regionAnalysis.ToList(),\n            GeneratedAt = DateTime.UtcNow\n        };\n    }\n}\n```\n\n### Configuration Management\n\n```csharp\npublic class ConfigurationValidator\n{\n    public ValidationResult ValidateConfiguration(\n        IEnumerable<ConfigurationItem> items)\n    {\n        var errors = new List<string>();\n        var warnings = new List<string>();\n        \n        // Check for duplicates\n        var duplicates = items\n            .GroupBy(i => i.Key)\n            .Where(g => g.Count() > 1)\n            .Select(g => g.Key);\n        \n        if (!duplicates.IsNullOrEmpty())\n        {\n            errors.Add($\"Duplicate keys found: {string.Join(\", \", duplicates)}\");\n        }\n        \n        // Check for required items\n        var required = GetRequiredKeys();\n        var missing = required.ExceptBy(items, r => r, i => i.Key);\n        \n        if (!missing.IsNullOrEmpty())\n        {\n            errors.Add($\"Missing required keys: {string.Join(\", \", missing)}\");\n        }\n        \n        // Check for deprecated items\n        var deprecated = GetDeprecatedKeys();\n        var foundDeprecated = items\n            .Where(i => deprecated.Contains(i.Key))\n            .Select(i => i.Key);\n        \n        if (!foundDeprecated.IsNullOrEmpty())\n        {\n            warnings.Add($\"Deprecated keys found: {string.Join(\", \", foundDeprecated)}\");\n        }\n        \n        return new ValidationResult\n        {\n            IsValid = errors.IsNullOrEmpty(),\n            Errors = errors,\n            Warnings = warnings\n        };\n    }\n}\n```\n\n### Bulk Operations\n\n```csharp\npublic class BulkDataProcessor\n{\n    private readonly IRepository _repository;\n    private readonly ILogger _logger;\n    \n    public async Task<BulkResult> BulkUpdateAsync<T>(\n        IEnumerable<T> items,\n        int batchSize = 100) where T : class\n    {\n        var successCount = 0;\n        var errorCount = 0;\n        var errors = new List<string>();\n        \n        await items\n            .EmptyIfNull()\n            .ProcessInBatchesAsync(batchSize, async batch =>\n            {\n                try\n                {\n                    await _repository.BulkUpdateAsync(batch);\n                    var count = batch.Count();\n                    successCount += count;\n                    _logger.LogInformation($\"Successfully updated {count} items\");\n                }\n                catch (Exception ex)\n                {\n                    var count = batch.Count();\n                    errorCount += count;\n                    errors.Add($\"Batch error: {ex.Message}\");\n                    _logger.LogError(ex, $\"Failed to update batch of {count} items\");\n                }\n            });\n        \n        return new BulkResult\n        {\n            SuccessCount = successCount,\n            ErrorCount = errorCount,\n            Errors = errors\n        };\n    }\n}\n```\n\n## Performance Considerations\n\n### Deferred Execution\n- Most operations use deferred execution (lazy evaluation)\n- Chain operations efficiently without intermediate collections\n- Materialize with `.ToList()` or `.ToArray()` when needed\n\n### Memory Efficiency\n```csharp\n// âœ… Efficient - deferred execution\nvar result = largeDataset\n    .Where(x => x.IsActive)\n    .Select(x => x.Name)\n    .Take(10);\n\n// âŒ Inefficient - immediate materialization\nvar result = largeDataset\n    .Where(x => x.IsActive).ToList() // Unnecessary materialization\n    .Select(x => x.Name).ToList()    // Another unnecessary materialization\n    .Take(10);\n```\n\n### Batch Size Optimization\n```csharp\n// Optimize batch size based on data characteristics\nvar batchSize = items.Count() switch\n{\n    < 1000 => 50,\n    < 10000 => 100,\n    < 100000 => 500,\n    _ => 1000\n};\n\nitems.ProcessInBatches(batchSize, ProcessBatch);\n```\n\n## Thread Safety\n\n- Extension methods are thread-safe (no shared state)\n- Be cautious with underlying collections that may not be thread-safe\n- Consider using concurrent collections for parallel processing\n\n```csharp\n// Thread-safe parallel processing\nvar results = new ConcurrentBag<ProcessedItem>();\n\nParallel.ForEach(items.ChunkBy(100), chunk =>\n{\n    var processed = ProcessChunk(chunk);\n    foreach (var item in processed)\n    {\n        results.Add(item);\n    }\n});\n```\n\n## Best Practices\n\n1. **Use Deferred Execution**: Chain operations before materializing\n2. **Handle Null Collections**: Use `EmptyIfNull()` for safety\n3. **Optimize Batch Sizes**: Choose appropriate batch sizes for your data\n4. **Validate Input**: Check for null or empty collections when appropriate\n5. **Consider Memory Usage**: Be mindful of materializing large collections\n6. **Use Appropriate Extensions**: Choose the right extension for your use case
